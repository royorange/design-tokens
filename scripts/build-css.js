const fs = require('fs-extra');
const path = require('path');
const _ = require('lodash');

/**
 * CSS/Web æ„å»ºè„šæœ¬
 * ç”Ÿæˆ CSS å˜é‡ã€JavaScript å¯¹è±¡å’Œ TypeScript å®šä¹‰
 * é€‚ç”¨äºæ‰€æœ‰ Web é¡¹ç›®ï¼ˆReactã€Vueã€åŸç”Ÿ JS ç­‰ï¼‰
 */

const TOKENS_PATH = path.join(__dirname, '../tokens/transformed/tokens.json');
const OUTPUT_PATH = path.join(__dirname, '../packages/css');
const CSS_PATH = path.join(OUTPUT_PATH, 'css');

// ç¡®ä¿è¾“å‡ºç›®å½•å­˜åœ¨
fs.ensureDirSync(OUTPUT_PATH);
fs.ensureDirSync(CSS_PATH);

/**
 * ç”Ÿæˆ CSS å˜é‡å
 */
function toCssVarName(path) {
  return '--' + path.join('-').replace(/\./g, '-');
}

/**
 * ç”Ÿæˆ CSS å˜é‡
 */
function generateCssVariables(tokens) {
  let css = '/* Generated by Design Tokens - DO NOT EDIT */\n\n';
  
  // Root variables (light mode)
  css += ':root {\n';
  // Global tokens
  css += generateCssVarsFromObject(tokens.global, []);
  // Light theme semantic tokens
  if (tokens.light) {
    css += generateCssVarsFromObject(tokens.light, ['theme']);
  }
  css += '}\n\n';
  
  // Dark mode
  css += '@media (prefers-color-scheme: dark) {\n';
  css += '  :root {\n';
  if (tokens.dark) {
    css += generateCssVarsFromObject(tokens.dark, ['theme'], '    ');
  }
  css += '  }\n';
  css += '}\n\n';
  
  // Dark mode class
  css += '.dark {\n';
  if (tokens.dark) {
    css += generateCssVarsFromObject(tokens.dark, ['theme'], '  ');
  }
  css += '}\n';
  
  return css;
}

/**
 * é€’å½’ç”Ÿæˆ CSS å˜é‡
 */
function generateCssVarsFromObject(obj, path = [], indent = '  ') {
  let css = '';
  
  Object.entries(obj).forEach(([key, value]) => {
    const currentPath = [...path, key];
    
    if (value && typeof value === 'object' && !value.value) {
      css += generateCssVarsFromObject(value, currentPath, indent);
    } else if (value && value.value) {
      const varName = toCssVarName(currentPath);
      const varValue = value.type === 'spacing' ? `${value.value}px` : 
                      value.type === 'borderRadius' ? `${value.value}px` :
                      value.type === 'fontSizes' ? `${value.value}px` :
                      value.value;
      css += `${indent}${varName}: ${varValue};\n`;
    }
  });
  
  return css;
}

/**
 * ç”Ÿæˆè¯­ä¹‰åŒ– CSS å˜é‡
 */
function generateSemanticCssVars(semantic, component, indent = '  ') {
  let css = '';
  
  // Semantic colors
  if (semantic?.color) {
    Object.entries(semantic.color).forEach(([category, values]) => {
      Object.entries(values).forEach(([key, config]) => {
        const varName = `--color-${category}-${key}`;
        css += `${indent}${varName}: ${config.value};\n`;
      });
    });
  }
  
  // Component tokens
  if (component) {
    Object.entries(component).forEach(([componentName, componentValues]) => {
      Object.entries(componentValues).forEach(([prop, config]) => {
        if (typeof config === 'object' && config.value) {
          const varName = `--${componentName}-${prop.replace(/\./g, '-')}`;
          css += `${indent}${varName}: ${config.value};\n`;
        }
      });
    });
  }
  
  return css;
}

/**
 * ç”Ÿæˆ JavaScript tokens å¯¹è±¡
 */
function generateJsTokens(tokens) {
  const jsTokens = {
    colors: {},
    spacing: {},
    radius: {},
    fontSize: {},
    semantic: {
      light: {},
      dark: {}
    },
    components: {}
  };
  
  // Global tokens
  if (tokens.global) {
    // Colors
    if (tokens.global.color) {
      Object.entries(tokens.global.color).forEach(([colorName, shades]) => {
        if (typeof shades === 'object' && !shades.value) {
          jsTokens.colors[colorName] = {};
          Object.entries(shades).forEach(([shade, config]) => {
            jsTokens.colors[colorName][shade] = config.value;
          });
        } else if (shades.value) {
          jsTokens.colors[colorName] = shades.value;
        }
      });
    }
    
    // Spacing
    if (tokens.global.spacing) {
      Object.entries(tokens.global.spacing).forEach(([key, config]) => {
        jsTokens.spacing[key] = `${config.value}px`;
      });
    }
    
    // Border radius
    if (tokens.global.radius) {
      Object.entries(tokens.global.radius).forEach(([key, config]) => {
        jsTokens.radius[key] = config.value === 9999 ? '9999px' : `${config.value}px`;
      });
    }
    
    // Font sizes
    if (tokens.global.fontSize) {
      Object.entries(tokens.global.fontSize).forEach(([key, config]) => {
        jsTokens.fontSize[key] = `${config.value}px`;
      });
    }
    
    // Font families
    if (tokens.global.fontFamily) {
      jsTokens.fontFamily = {};
      Object.entries(tokens.global.fontFamily).forEach(([key, config]) => {
        jsTokens.fontFamily[key] = config.value;
      });
    }
  }
  
  // Semantic tokens
  ['light', 'dark'].forEach(theme => {
    if (tokens[theme]) {
      jsTokens.semantic[theme] = processSemanticTokens(tokens[theme]);
    }
  });
  
  // Component tokens - not used in current structure
  jsTokens.components = {};
  
  return jsTokens;
}

/**
 * å¤„ç†è¯­ä¹‰åŒ– tokens
 */
function processSemanticTokens(semantic) {
  const result = {};
  
  Object.entries(semantic).forEach(([category, values]) => {
    result[category] = {};
    Object.entries(values).forEach(([key, config]) => {
      result[category][key] = config.value;
    });
  });
  
  return result;
}

/**
 * ç”Ÿæˆ TypeScript å®šä¹‰
 */
function generateTypeDefinitions() {
  return `// Generated by Design Tokens - DO NOT EDIT

export interface ColorShades {
  50: string;
  100: string;
  200: string;
  300: string;
  400: string;
  500: string;
  600: string;
  700: string;
  800: string;
  900: string;
}

export interface DesignTokens {
  colors: {
    primary: ColorShades;
    neutral: ColorShades;
    white: string;
    black: string;
    [key: string]: ColorShades | string;
  };
  spacing: Record<string, string>;
  radius: Record<string, string>;
  fontSize: Record<string, string>;
  fontFamily?: Record<string, string>;
  semantic: {
    light: SemanticTokens;
    dark: SemanticTokens;
  };
  components: Record<string, any>;
}

export interface SemanticTokens {
  color?: {
    background?: Record<string, string>;
    text?: Record<string, string>;
    border?: Record<string, string>;
  };
}

export interface ComponentTokens {
  [component: string]: Record<string, any>;
}

export declare const tokens: DesignTokens;

export function useTheme(theme?: 'light' | 'dark'): SemanticTokens;
export function getCssVar(path: string): string;
`;
}

/**
 * ç”Ÿæˆä¸»å…¥å£æ–‡ä»¶
 */
function generateIndexFile() {
  return `// Generated by Design Tokens - DO NOT EDIT
const tokens = require('./tokens.json');

// Helper to get CSS variable value
function getCssVar(path) {
  const varName = '--' + path.replace(/\\./g, '-');
  if (typeof window !== 'undefined') {
    return getComputedStyle(document.documentElement).getPropertyValue(varName);
  }
  return varName;
}

// Helper to use theme-specific tokens
function useTheme(theme = 'light') {
  return tokens[theme] || {};
}

module.exports = {
  tokens,
  useTheme,
  getCssVar
};
`;
}

/**
 * ç”Ÿæˆ ESM å…¥å£æ–‡ä»¶
 */
function generateEsmFile() {
  return `// Generated by Design Tokens - DO NOT EDIT
import tokensData from './tokens.json';

export const tokens = tokensData;

// Helper to get CSS variable value
export function getCssVar(path) {
  const varName = '--' + path.replace(/\\./g, '-');
  if (typeof window !== 'undefined') {
    return getComputedStyle(document.documentElement).getPropertyValue(varName);
  }
  return varName;
}

// Helper to use theme-specific tokens
export function useTheme(theme = 'light') {
  return {
    ...tokens.semantic[theme],
    ...tokens.components[theme]
  };
}

export default tokens;
`;
}

/**
 * ä¸»æ„å»ºå‡½æ•°
 */
async function buildCSS() {
  try {
    console.log('ğŸ”„ Building CSS/Web package...');
    
    // è¯»å– tokens
    const tokens = await fs.readJSON(TOKENS_PATH);
    
    // ç”Ÿæˆ CSS å˜é‡
    const cssContent = generateCssVariables(tokens);
    await fs.writeFile(path.join(CSS_PATH, 'variables.css'), cssContent);
    
    // ç”Ÿæˆ JavaScript tokens
    const jsTokens = generateJsTokens(tokens);
    await fs.writeJSON(
      path.join(OUTPUT_PATH, 'tokens.json'),
      jsTokens,
      { spaces: 2 }
    );
    
    // ç”Ÿæˆ TypeScript å®šä¹‰
    await fs.writeFile(
      path.join(OUTPUT_PATH, 'index.d.ts'),
      generateTypeDefinitions()
    );
    
    // ç”Ÿæˆ CommonJS å…¥å£
    await fs.writeFile(
      path.join(OUTPUT_PATH, 'index.js'),
      generateIndexFile()
    );
    
    // ç”Ÿæˆ ESM å…¥å£
    await fs.writeFile(
      path.join(OUTPUT_PATH, 'index.mjs'),
      generateEsmFile()
    );
    
    // åˆ›å»º package.json
    const packageJson = {
      name: '@wisburg/design-tokens-css',
      version: '1.0.0',
      description: 'Design tokens CSS variables and utilities for web applications',
      main: 'index.js',
      module: 'index.mjs',
      types: 'index.d.ts',
      exports: {
        '.': {
          require: './index.js',
          import: './index.mjs',
          types: './index.d.ts'
        },
        './css/variables.css': './css/variables.css',
        './tokens.json': './tokens.json'
      },
      sideEffects: ["./css/variables.css"]
    };
    
    await fs.writeJSON(
      path.join(OUTPUT_PATH, 'package.json'),
      packageJson,
      { spaces: 2 }
    );
    
    // åˆ›å»ºä½¿ç”¨ç¤ºä¾‹
    const exampleContent = `// Example usage in Web projects

// 1. Import CSS variables (in your main CSS/JS file)
import '@wisburg/design-tokens-css/css/variables.css';

// 2. Use tokens in JavaScript
import { tokens, useTheme, getCssVar } from '@wisburg/design-tokens-css';

// Component example
export function Button({ variant = 'primary' }) {
  const theme = useTheme(); // Uses current theme (light/dark)
  
  return (
    <button
      style={{
        backgroundColor: tokens.colors.primary[500],
        padding: \`\${tokens.spacing[4]} \${tokens.spacing[6]}\`,
        borderRadius: tokens.radius.md,
        color: tokens.colors.white
      }}
    >
      Click me
    </button>
  );
}

// 3. Use CSS variables
export function Card() {
  return (
    <div className="card">
      <style jsx>{\`
        .card {
          background: var(--color-background-elevated);
          border: 1px solid var(--color-border-default);
          border-radius: var(--radius-lg);
          padding: var(--spacing-4);
        }
      \`}</style>
      Card content
    </div>
  );
}

// 4. Styled Components example
import styled from 'styled-components';

const StyledButton = styled.button\`
  background: var(--color-primary-500);
  color: var(--color-white);
  padding: var(--spacing-3) var(--spacing-4);
  border-radius: var(--radius-md);
  
  &:hover {
    background: var(--color-primary-600);
  }
\`;
`;
    
    await fs.writeFile(
      path.join(OUTPUT_PATH, 'example.jsx'),
      exampleContent
    );
    
    console.log('âœ… CSS/Web package built successfully');
    
  } catch (error) {
    console.error('âŒ CSS build failed:', error);
    process.exit(1);
  }
}

// å¦‚æœç›´æ¥è¿è¡Œæ­¤è„šæœ¬
if (require.main === module) {
  buildCSS();
}

module.exports = { buildCSS };
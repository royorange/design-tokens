const fs = require('fs-extra');
const path = require('path');
const _ = require('lodash');

/**
 * React/Next.js ÊûÑÂª∫ËÑöÊú¨
 * ÁîüÊàê CSS ÂèòÈáè„ÄÅJavaScript ÂØπË±°Âíå TypeScript ÂÆö‰πâ
 */

const TOKENS_PATH = path.join(__dirname, '../tokens/transformed/tokens.json');
const OUTPUT_PATH = path.join(__dirname, '../packages/react');
const CSS_PATH = path.join(OUTPUT_PATH, 'css');

// Á°Æ‰øùËæìÂá∫ÁõÆÂΩïÂ≠òÂú®
fs.ensureDirSync(OUTPUT_PATH);
fs.ensureDirSync(CSS_PATH);

/**
 * ÁîüÊàê CSS ÂèòÈáèÂêç
 */
function toCssVarName(path) {
  return '--' + path.join('-').replace(/\./g, '-');
}

/**
 * ÁîüÊàê CSS ÂèòÈáè
 */
function generateCssVariables(tokens) {
  let css = '/* Generated by Design Tokens - DO NOT EDIT */\n\n';
  
  // Root variables (light mode)
  css += ':root {\n';
  css += generateCssVarsFromObject(tokens.primitive, []);
  css += generateSemanticCssVars(tokens.semantic.light, tokens.component.light);
  css += '}\n\n';
  
  // Dark mode
  css += '@media (prefers-color-scheme: dark) {\n';
  css += '  :root {\n';
  css += generateSemanticCssVars(tokens.semantic.dark, tokens.component.dark, '    ');
  css += '  }\n';
  css += '}\n\n';
  
  // Dark mode class
  css += '.dark {\n';
  css += generateSemanticCssVars(tokens.semantic.dark, tokens.component.dark, '  ');
  css += '}\n';
  
  return css;
}

/**
 * ÈÄíÂΩíÁîüÊàê CSS ÂèòÈáè
 */
function generateCssVarsFromObject(obj, path = [], indent = '  ') {
  let css = '';
  
  Object.entries(obj).forEach(([key, value]) => {
    const currentPath = [...path, key];
    
    if (value && typeof value === 'object' && !value.value) {
      css += generateCssVarsFromObject(value, currentPath, indent);
    } else if (value && value.value) {
      const varName = toCssVarName(currentPath);
      const varValue = value.type === 'spacing' ? `${value.value}px` : 
                      value.type === 'borderRadius' ? `${value.value}px` :
                      value.type === 'fontSizes' ? `${value.value}px` :
                      value.value;
      css += `${indent}${varName}: ${varValue};\n`;
    }
  });
  
  return css;
}

/**
 * ÁîüÊàêËØ≠‰πâÂåñ CSS ÂèòÈáè
 */
function generateSemanticCssVars(semantic, component, indent = '  ') {
  let css = '';
  
  // Semantic colors
  if (semantic?.color) {
    Object.entries(semantic.color).forEach(([category, values]) => {
      Object.entries(values).forEach(([key, config]) => {
        const varName = `--color-${category}-${key}`;
        css += `${indent}${varName}: ${config.value};\n`;
      });
    });
  }
  
  // Component tokens
  if (component) {
    Object.entries(component).forEach(([componentName, componentValues]) => {
      Object.entries(componentValues).forEach(([prop, config]) => {
        if (typeof config === 'object' && config.value) {
          const varName = `--${componentName}-${prop.replace(/\./g, '-')}`;
          css += `${indent}${varName}: ${config.value};\n`;
        }
      });
    });
  }
  
  return css;
}

/**
 * ÁîüÊàê JavaScript tokens ÂØπË±°
 */
function generateJsTokens(tokens) {
  const jsTokens = {
    colors: {},
    spacing: {},
    radius: {},
    fontSize: {},
    semantic: {
      light: {},
      dark: {}
    },
    components: {}
  };
  
  // Primitive tokens
  if (tokens.primitive.color) {
    Object.entries(tokens.primitive.color).forEach(([colorName, shades]) => {
      if (typeof shades === 'object' && !shades.value) {
        jsTokens.colors[colorName] = {};
        Object.entries(shades).forEach(([shade, config]) => {
          jsTokens.colors[colorName][shade] = config.value;
        });
      } else if (shades.value) {
        jsTokens.colors[colorName] = shades.value;
      }
    });
  }
  
  // Spacing
  if (tokens.primitive.spacing) {
    Object.entries(tokens.primitive.spacing).forEach(([key, config]) => {
      jsTokens.spacing[key] = `${config.value}px`;
    });
  }
  
  // Border radius
  if (tokens.primitive.radius) {
    Object.entries(tokens.primitive.radius).forEach(([key, config]) => {
      jsTokens.radius[key] = config.value === '9999' ? '9999px' : `${config.value}px`;
    });
  }
  
  // Font sizes
  if (tokens.primitive.fontSize) {
    Object.entries(tokens.primitive.fontSize).forEach(([key, config]) => {
      jsTokens.fontSize[key] = `${config.value}px`;
    });
  }
  
  // Semantic tokens
  ['light', 'dark'].forEach(theme => {
    if (tokens.semantic[theme]) {
      jsTokens.semantic[theme] = processSemanticTokens(tokens.semantic[theme]);
    }
  });
  
  // Component tokens
  if (tokens.component) {
    jsTokens.components = tokens.component;
  }
  
  return jsTokens;
}

/**
 * Â§ÑÁêÜËØ≠‰πâÂåñ tokens
 */
function processSemanticTokens(semantic) {
  const result = {};
  
  Object.entries(semantic).forEach(([category, values]) => {
    result[category] = {};
    Object.entries(values).forEach(([key, config]) => {
      result[category][key] = config.value;
    });
  });
  
  return result;
}

/**
 * ÁîüÊàê TypeScript ÂÆö‰πâ
 */
function generateTypeDefinitions() {
  return `// Generated by Design Tokens - DO NOT EDIT

export interface ColorShades {
  50: string;
  100: string;
  200: string;
  300: string;
  400: string;
  500: string;
  600: string;
  700: string;
  800: string;
  900: string;
}

export interface DesignTokens {
  colors: {
    primary: ColorShades;
    neutral: ColorShades;
    white: string;
    black: string;
    [key: string]: ColorShades | string;
  };
  spacing: Record<string, string>;
  radius: Record<string, string>;
  fontSize: Record<string, string>;
  semantic: {
    light: SemanticTokens;
    dark: SemanticTokens;
  };
  components: {
    light: ComponentTokens;
    dark: ComponentTokens;
  };
}

export interface SemanticTokens {
  color?: {
    background?: Record<string, string>;
    text?: Record<string, string>;
    border?: Record<string, string>;
  };
}

export interface ComponentTokens {
  [component: string]: Record<string, any>;
}

export declare const tokens: DesignTokens;

export function useTheme(theme?: 'light' | 'dark'): SemanticTokens;
export function getCssVar(path: string): string;
`;
}

/**
 * ÁîüÊàê‰∏ªÂÖ•Âè£Êñá‰ª∂
 */
function generateIndexFile() {
  return `// Generated by Design Tokens - DO NOT EDIT
const tokens = require('./tokens.json');

// Helper to get CSS variable value
function getCssVar(path) {
  const varName = '--' + path.replace(/\\./g, '-');
  if (typeof window !== 'undefined') {
    return getComputedStyle(document.documentElement).getPropertyValue(varName);
  }
  return varName;
}

// Helper to use theme-specific tokens
function useTheme(theme = 'light') {
  return {
    ...tokens.semantic[theme],
    ...tokens.components[theme]
  };
}

module.exports = {
  tokens,
  useTheme,
  getCssVar
};
`;
}

/**
 * ÁîüÊàê ESM ÂÖ•Âè£Êñá‰ª∂
 */
function generateEsmFile() {
  return `// Generated by Design Tokens - DO NOT EDIT
import tokensData from './tokens.json';

export const tokens = tokensData;

// Helper to get CSS variable value
export function getCssVar(path) {
  const varName = '--' + path.replace(/\\./g, '-');
  if (typeof window !== 'undefined') {
    return getComputedStyle(document.documentElement).getPropertyValue(varName);
  }
  return varName;
}

// Helper to use theme-specific tokens
export function useTheme(theme = 'light') {
  return {
    ...tokens.semantic[theme],
    ...tokens.components[theme]
  };
}

export default tokens;
`;
}

/**
 * ‰∏ªÊûÑÂª∫ÂáΩÊï∞
 */
async function buildReact() {
  try {
    console.log('üîÑ Building React package...');
    
    // ËØªÂèñ tokens
    const tokens = await fs.readJSON(TOKENS_PATH);
    
    // ÁîüÊàê CSS ÂèòÈáè
    const cssContent = generateCssVariables(tokens);
    await fs.writeFile(path.join(CSS_PATH, 'variables.css'), cssContent);
    
    // ÁîüÊàê JavaScript tokens
    const jsTokens = generateJsTokens(tokens);
    await fs.writeJSON(
      path.join(OUTPUT_PATH, 'tokens.json'),
      jsTokens,
      { spaces: 2 }
    );
    
    // ÁîüÊàê TypeScript ÂÆö‰πâ
    await fs.writeFile(
      path.join(OUTPUT_PATH, 'index.d.ts'),
      generateTypeDefinitions()
    );
    
    // ÁîüÊàê CommonJS ÂÖ•Âè£
    await fs.writeFile(
      path.join(OUTPUT_PATH, 'index.js'),
      generateIndexFile()
    );
    
    // ÁîüÊàê ESM ÂÖ•Âè£
    await fs.writeFile(
      path.join(OUTPUT_PATH, 'index.mjs'),
      generateEsmFile()
    );
    
    // ÂàõÂª∫ package.json
    const packageJson = {
      name: '@wisburg/design-tokens-react',
      version: '1.0.0',
      description: 'Design tokens for React applications',
      main: 'index.js',
      module: 'index.mjs',
      types: 'index.d.ts',
      exports: {
        '.': {
          require: './index.js',
          import: './index.mjs',
          types: './index.d.ts'
        },
        './css/variables.css': './css/variables.css',
        './tokens.json': './tokens.json'
      },
      sideEffects: false,
      peerDependencies: {
        'react': '>=16.8.0'
      }
    };
    
    await fs.writeJSON(
      path.join(OUTPUT_PATH, 'package.json'),
      packageJson,
      { spaces: 2 }
    );
    
    // ÂàõÂª∫‰ΩøÁî®Á§∫‰æã
    const exampleContent = `// Example usage in React/Next.js

// 1. Import CSS variables (in _app.tsx or layout.tsx)
import '@wisburg/design-tokens-react/css/variables.css';

// 2. Use tokens in JavaScript
import { tokens, useTheme, getCssVar } from '@wisburg/design-tokens-react';

// Component example
export function Button({ variant = 'primary' }) {
  const theme = useTheme(); // Uses current theme (light/dark)
  
  return (
    <button
      style={{
        backgroundColor: tokens.colors.primary[500],
        padding: \`\${tokens.spacing[4]} \${tokens.spacing[6]}\`,
        borderRadius: tokens.radius.md,
        color: tokens.colors.white
      }}
    >
      Click me
    </button>
  );
}

// 3. Use CSS variables
export function Card() {
  return (
    <div className="card">
      <style jsx>{\`
        .card {
          background: var(--color-background-elevated);
          border: 1px solid var(--color-border-default);
          border-radius: var(--radius-lg);
          padding: var(--spacing-4);
        }
      \`}</style>
      Card content
    </div>
  );
}

// 4. Styled Components example
import styled from 'styled-components';

const StyledButton = styled.button\`
  background: var(--color-primary-500);
  color: var(--color-white);
  padding: var(--spacing-3) var(--spacing-4);
  border-radius: var(--radius-md);
  
  &:hover {
    background: var(--color-primary-600);
  }
\`;
`;
    
    await fs.writeFile(
      path.join(OUTPUT_PATH, 'example.jsx'),
      exampleContent
    );
    
    console.log('‚úÖ React package built successfully');
    
  } catch (error) {
    console.error('‚ùå React build failed:', error);
    process.exit(1);
  }
}

// Â¶ÇÊûúÁõ¥Êé•ËøêË°åÊ≠§ËÑöÊú¨
if (require.main === module) {
  buildReact();
}

module.exports = { buildReact };